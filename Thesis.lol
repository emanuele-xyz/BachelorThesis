\contentsline {lstlisting}{\numberline {2.1}Create Vulkan instance}{11}{}%
\contentsline {lstlisting}{\numberline {2.2}VkInstanceCreateInfo initialization}{11}{}%
\contentsline {lstlisting}{\numberline {2.3}VkApplicationInfo initialization}{11}{}%
\contentsline {lstlisting}{\numberline {2.4}Enabling the Khronos validation layer}{12}{}%
\contentsline {lstlisting}{\numberline {2.5}Enabling an extention to handle validation layer debug messages}{12}{}%
\contentsline {lstlisting}{\numberline {2.6}Setting up debug extension callbacks}{13}{}%
\contentsline {lstlisting}{\numberline {2.7}Extension function proxy}{13}{}%
\contentsline {lstlisting}{\numberline {2.8}Vulkan Instance Cleanup}{14}{}%
\contentsline {lstlisting}{\numberline {2.9}Creating a window handle using Win32 API}{14}{}%
\contentsline {lstlisting}{\numberline {2.10}Compute window width and height}{15}{}%
\contentsline {lstlisting}{\numberline {2.11}Register Window Class}{15}{}%
\contentsline {lstlisting}{\numberline {2.12}Window Procedure}{16}{}%
\contentsline {lstlisting}{\numberline {2.13}Process Window Messages}{16}{}%
\contentsline {lstlisting}{\numberline {2.14}Window Cleanup}{16}{}%
\contentsline {lstlisting}{\numberline {2.15}Create Presentation Surface}{17}{}%
\contentsline {lstlisting}{\numberline {2.16}Filling in a VkWin32SurfaceCreateInfoKHR struct}{17}{}%
\contentsline {lstlisting}{\numberline {2.17}Presentation Surface Extensions}{17}{}%
\contentsline {lstlisting}{\numberline {2.18}Presentation Surface Cleanup}{18}{}%
\contentsline {lstlisting}{\numberline {2.19}Check for graphics operations support}{18}{}%
\contentsline {lstlisting}{\numberline {2.20}Check for present operations support}{19}{}%
\contentsline {lstlisting}{\numberline {2.21}Device extension for image presentation to the screen}{19}{}%
\contentsline {lstlisting}{\numberline {2.22}Create a logical device}{20}{}%
\contentsline {lstlisting}{\numberline {2.23}Create info struct when queue families are the same}{20}{}%
\contentsline {lstlisting}{\numberline {2.24}Create info struct when queue families are different}{21}{}%
\contentsline {lstlisting}{\numberline {2.25}Retrieve queue handles}{21}{}%
\contentsline {lstlisting}{\numberline {2.26}Create a swapchain}{22}{}%
\contentsline {lstlisting}{\numberline {2.27}Configure our swapchain}{22}{}%
\contentsline {lstlisting}{\numberline {2.28}Configure queue ownership over swapchain images}{23}{}%
\contentsline {lstlisting}{\numberline {2.29}Select swapchain image count}{23}{}%
\contentsline {lstlisting}{\numberline {2.30}Select swapchain image format}{24}{}%
\contentsline {lstlisting}{\numberline {2.31}Select swapchain image extent}{24}{}%
\contentsline {lstlisting}{\numberline {2.32}Select swapchain present mode}{25}{}%
\contentsline {lstlisting}{\numberline {2.33}Create swapchain image views}{26}{}%
\contentsline {lstlisting}{\numberline {2.34}Structure of our application}{27}{}%
\contentsline {lstlisting}{\numberline {3.1}Create semaphores}{28}{}%
\contentsline {lstlisting}{\numberline {3.2}Create graphics command pool}{28}{}%
\contentsline {lstlisting}{\numberline {3.3}Configure our graphics command pool}{29}{}%
\contentsline {lstlisting}{\numberline {3.4}Allocate a command buffer from our graphics command pool}{29}{}%
\contentsline {lstlisting}{\numberline {3.5}Configure command buffer creation}{29}{}%
\contentsline {lstlisting}{\numberline {3.6}Create a fence for our command buffer}{29}{}%
\contentsline {lstlisting}{\numberline {3.7}Create a render pass}{30}{}%
\contentsline {lstlisting}{\numberline {3.8}Configure our render pass}{30}{}%
\contentsline {lstlisting}{\numberline {3.9}Render pass attachment descriptions}{31}{}%
\contentsline {lstlisting}{\numberline {3.10}Render pass subpass descriptions}{31}{}%
\contentsline {lstlisting}{\numberline {3.11}Acquire the next swapchain image that will be presented}{32}{}%
\contentsline {lstlisting}{\numberline {3.12}Wait for command buffer execution to finish}{32}{}%
\contentsline {lstlisting}{\numberline {3.13}Create a new framebuffer}{32}{}%
\contentsline {lstlisting}{\numberline {3.14}Configure our framebuffer}{33}{}%
\contentsline {lstlisting}{\numberline {3.15}Boilerplate code for recording a command buffer}{33}{}%
\contentsline {lstlisting}{\numberline {3.16}Change window clear color over time}{33}{}%
\contentsline {lstlisting}{\numberline {3.17}Clear the window using a render pass}{33}{}%
\contentsline {lstlisting}{\numberline {3.18}Configure our render pass instance}{34}{}%
\contentsline {lstlisting}{\numberline {3.19}Submit command buffer to the GPU}{34}{}%
\contentsline {lstlisting}{\numberline {3.20}Configure command buffer submission}{35}{}%
\contentsline {lstlisting}{\numberline {3.21}Issue a present command}{35}{}%
\contentsline {lstlisting}{\numberline {3.22}Configure present command submission}{35}{}%
\contentsline {lstlisting}{\numberline {3.23}Structure of our application}{36}{}%
