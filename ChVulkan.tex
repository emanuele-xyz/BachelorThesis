\chapter{Vulkan}

\section{Software Rendering}

In the early days of computer graphics, if you wanted to draw an image on the
screen, you had to directly instruct the CPU to do so.
For example, drawing a line segment would require to run a loop and set the
color of each pixel lying along the line.
This is called software rendering.
Because software rendering required a lot of CPU time, graphics performance
was very slow.

\section{GPUs}

In 1981, Jim Clark, a professor at Stanford, had the idea to build
ad hoc hardware for making graphics operations faster.
This hardware is what we today call a graphics processing unit, or
GPU, for short.
The massive increase in graphics performance is thanks to two factors.
GPUs have several specialized processors that can work in parallel.
GPUs also have their own dedicated memory.
GPU processors have very fast access to this memory, much faster than
their access time on RAM.

\section{Graphics APIs}

Now that computers had specialized graphics hardware, programmers
needed a way to interact and use them effectively.
To simplify this process, each graphics card manufacturer also developed
an graphics API to directly interact with their custom hardware.

Drawing using a graphics API is much simpler than software rendering.
We simply need to instruct the CPU to send the appropriate commands and data
to the GPU.
The GPU will then be responsible for executing the commands.
In this way, the CPU offloads most of the work to the GPU, which is optimized
to perform graphics commands very quickly.
For example, if we want to draw a line segment, we simply need to send to the
GPU the two points that define the line segment itself, and then send a
command that tells the GPU to draw a segment.

\section{OpenGL}

Using a graphics API was very convenient for programmers.
The problem was that each graphics card manufacturer had their own custom
graphics API.
Thus, if you wanted to make your software portable to other platforms using
a different graphics card, you had to rewrite the program using another API.
This was obviously a nuisance to many people.
Adding to this problem was the fact that different graphics APIs could
have entirely different ideas on how to do graphics, making porting an already
existing program to another graphics API even more difficult.

At that time, the leading graphics card manufacturer was SGI.
The graphics API that was used to interact with SGI hardware was called GL.
With time, other companies realized that GL was a very good graphics API,
and wanted to let programmers work that way.
So, in 1992, the most prominent graphics card manufacturers and other companies
banded together to form a committee and created the OpenGL specification.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.10]{images/ChVulkan/OpenGlLogo.png}
    \caption{OpenGL logo}
    \label{fig::OpenGLLogo}
\end{figure}

OpenGL is based on the fact that software vendors have to
provide their own implementation that conforms to the OpenGL standard.
On the other hand, graphics card manufacturers have to provide programs
that allow OpenGL to talk to the underlying graphics hardware, what today we
call device drivers.

\section{OpenGL Issues}

With time, graphics hardware continued to evolve, and graphics cards started
to offer new functionalities.
To access these new GPU features, OpenGL had to be extended, adding new
concepts to the API, while still maintaining the older functionalities.
This lead to a growth in the API's complexity, which had to be shouldered by
the device drivers, making them more bloated.
Because of this, device drivers became inefficient and also riddled with bugs
caused by many inconsistencies between different OpenGL implementations.

GPUs were not the only thing to change.
CPUs also continued to evolve.
In particular, CPUs started to have more than one core, offering the possibility
of multithreading.
The problem is that OpenGL wasn't meant to be used in a multithreaded context,
being a strictly synchronous API.
There can be only one thread from which we can send commands to the GPU.
This obviously can be a big bottleneck for performance nowadays.

\section{Vulkan}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.10]{images/ChVulkan/VulkanLogo.png}
    \caption{Vulkan logo}
    \label{fig::VulkanLogo}
\end{figure}

Vulkan is OpenGL's spiritual successor.
It is a newer graphics API that is meant to abstract how modern GPUs work.
Vulkan doesn't suffer from the problems that plague OpenGL because it has been
designed from scratch and with modern GPU's architecture in mind.
Vulkan reduces the driver overhead by being more low level, allowing us to
write more performant code.
It is also designed to be easy to use in a multithreaded environment,
allowing us to submit GPU commands from multiple threads.
